Quick notes about SpaceToaster so I don't forget how anything works later on

gameloop() is called once on the page and starts the game. Numerous CSS attributes are initialized through javascript because it's nicer to set the values absolutely in code and convert them to CSS-friendly strings (with CSS units at the end).

var frameTimer = setInterval(...) starts the actual game loop. 16ms is approx 60fps (slightly slower). We're not using any delta time calculations right now so timings are hardcoded; setting a higher or lower value will make the entire game change in speed.

The jist of the entire codebase is this: On each step, every object in a tracking collection (gameObjects, effectObjects) has its update() function called once. The instance of the background and any sequences (levels) follow this same behavior with a step() function. The collision loop is called for each object in gameObjects on each step; if collisions are found, it calls the 'collide()' function of both objects with the type of object they collided with. Then it returns a change in point value (not a new value, just the amount that the existing point value should change).

Architecturally, the goal is for code to be fairly modular, and for most objects to manage their own state. Gameplay objects and particles are responsible for removing themselves from container collections and the viewport when destroyed, while sequences are responsible for reporting (via the .isCompleted property) when they are finished. The objective is that designs should be more generic as they effect more of the codebase, and should be more self-contained when they are more specific to a single functionality.

Gameplay objects should extend the GameplayObject class, which provides a few things that will be necessary for any object. Objects should then implement update(), and optionally destroy() and collide() if these are relevant to it. update() is called on every step and takes no arguments. collide() should accept a single argument matching a value in the 'gameplayObjects' constant, and a switch statement to handle relevant collisions. Objects that have a collide() function should have a field titled "objectType" populated with a value from the 'gameplayObjects' enum.
Gameplay objects' constructors also accept an array which tracks that object; this array will be referenced in that object's destroy() function. When destroy() is called, the object should remove itself from the page and from the referenced array.

In the gameplay loop, the 'gameObjects' array is the array we use for this, and contains all of these objects. For this reason, when instantiating a new gameplay object, the object must be added to the array, and the array must be passed to the object.

Toaster movement is still hardcoded into the main game loop; it's represented on the screen with a hardcoded div whose CSS attributes are updated in each call of the step() function, but its collision box is an instance of the ToasterCollision object which works like all the other game objects.

Level scripting:
A more thought-out level scripting system now exists! To script a level:
-Create a class extending 'sequence' from levels.js, and call super() in the constructor
-The level is scripted in the 'events' array. The array is iterated once per step, and responds to the following types:
Functions will be called on the step where they are reached.
Integers represent a frame delay; array iteration will not advance past that integer until that number of frames has passed.
Instances of other sequences will run, and array iteration will not resume until that sequence completes.

Sequence constructors do take an argument for a speed modifier, but it's up to the programmer to implement this in a given level script. 
A sequence indicates completion by changing its "isCompleted" field to true, and the base class will do this as soon as the level script has been executed fully. This may not always be desirable though, so there's an optional 'exitCondition' field which can be set with a lambda (or any boolean) to create additional conditions for a sequence to indicate completion. This could be used for something like "until all enemies have been destroyed" to keep sequences from running into each other, or to create sequences that can run indefinitely for a boss enemy. This field can be left null if this functionality isn't needed. It only gets checked after "isCompleted" has been set to true, at which point it will be checked on every frame, so be mindful of this if populating it with a function.

Effects:
There's now a particle effect system! Using it is functionally identical to using GameplayObjects; an effectObjects array has its contents' update() functions called on each step. The Particle class represents a single particle, which is instantiated at the indicated x and y positions, moves roughly 'speed' pixels per frame in the direction of 'angle', exists for 'duration' frames, and accepts a color (which can be any CSS color). The angle conversion is -not- incredibly accurate, it uses a rough exponential curve to approximate the angle. This is a stand-in until I learn better math. There's also a 'ParticleExplosion' type that uses Particle to make a fun explosion!

Particle effects are -not- baked into the base game objects, and this is done intentionally to keep from making a mess out of the various stateful components involved (and to leave greater flexibility about when, where, and what kind of effects may be desirable). The programmer should decide how to implement effects as it's desirable for a given sequence; the 'basicSequence.js' example does this by extending the enemy classes to create a generic explosion on destruction.
